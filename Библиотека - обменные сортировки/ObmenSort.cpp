#include <iostream>

using namespace std;

void ChetNechetSort(int MAS[], int n) // четно-нечетная сортировка
{
	int i, j, temp, countTemp = 0, a = 0, a1 = 0;

	for (i = 0; i < n; ++i)
	{
		a = countTemp;
		if (i % 2 == 0)
		{
			for (j = 2; j < n; j += 2)
			{
				if (MAS[j - 1] > MAS[j])
				{// обмен
					temp = MAS[j - 1];
					MAS[j - 1] = MAS[j];
					MAS[j] = temp;
					countTemp += 3;
				}
			}
		}
		else
		{
			for (j = 1; j < n; j += 2)
			{
				if (MAS[j - 1] > MAS[j])
				{ // обмен
					temp = MAS[j - 1];
					MAS[j - 1] = MAS[j];
					MAS[j] = temp;
					countTemp += 3;
				}

			}
		}
		if (a == countTemp)
		{
			a1++;
			if (a1 == 2)
			{
				break;
			}
		}
	}
}

void RacheskaSort(int MAS[], int n) // сортировка расческой
{
	int step = n, i, temp;

	while (step > 1) // внешний цикл, из которого выйдем, если step>1
	{
		if (step > 1) // если step>1, то делим step на 1.247 
		{
			step = step / 1.247;
		}
		for (i = 0; i + step < n; i++) //внутренний цикл для прохода по значениям
		{
			if (MAS[i] > MAS[i + step]) // сравниваем 2 значения
			{
				temp = MAS[i];  // запоминаем MAS[i]
				MAS[i] = MAS[i + step]; // меняем местами 2 значения (меньшее влево, большее вправо)
				MAS[i + step] = temp; // присваеваем число, которое запомнили раньше 
			}
		}
	}
}

void ProstObmenSort(int* MAS, int n)  // функция обменной сортировки (метод пузырька) по кнуту
{
	int BOUND = n - 1, t = n - 1, temp;
	do // цикл из которого выйдем, если t будет <= 0
	{
		t = 0;
		for (int j = 0; j <= BOUND - 1; j++) //цикл для прохода по массиву
		{
			if (MAS[j] > MAS[j + 1]) // условие обмена
			{
				temp = MAS[j]; //запоминаем элемент, который заменим
				MAS[j] = MAS[j + 1]; // выполняем перестановку
				MAS[j + 1] = temp;// возвращаем элемент заметсто переставленного
				t = j; //присваеваем новоее значение
			}
		}
		if (t != 0) // если t не равно 0, то присваиваем переменной BOUND значение t
		{
			BOUND = t;
		}
	} while (t > 0);
}

void QSort(int M[], int LG, int PG) // сортировка Хоара
{
	int i = LG, j = PG;
	// Находим разделительный элемент в середине массива
	double X = M[((LG + PG) / 2)];
	// Обход массив
	while (i <= j)
	{
		//Находим элемент, который больше или равен разделительному элементу от //левого индекса.
		while (M[i] < X)
		{
			++i;
		}
		// Находим элемент, который меньше или равен разделительному элементу от //правого индекса.
		while (M[j] > X)
		{
			--j;
		}
		// Если индексы не пересекаются, меняем элементы
		if (i <= j)
		{
			int T;
			T = M[i];
			M[i] = M[j];
			M[j] = T;
			++i;
			--j;
		} //if
	} //while
// Если ПРАВЫЙ индекс не достиг ЛЕВОЙ границы массива,то нужно повторить сортировку ЛЕВОЙ части.
	if (LG < j) QSort(M, LG, j);
	//Если ЛЕВЫЙ индекс не достиг ПРАВОЙ границы массива,то нужно повторить сортировку ПРАВОЙ части.
	if (i < PG) QSort(M, i, PG);
}// QSort

void GnomeSort(int MAS[], int n) // функция гномьей сортировки
{
	int i = 0, temp;
	while (i < n) // внешний цикл, из которого выйдем, если i>=n
	{
		if (i == 0 || MAS[i - 1] <= MAS[i]) //условие, при котором увеличиваем переменную i на 1
		{
			i++;
		}
		else // если условие не выполняется переходим к перестановке
		{
			temp = MAS[i]; // запоминаем элемент, которое заменим
			MAS[i] = MAS[i - 1];
			// заменяем элемент
			MAS[--i] = temp;// возвращаем элемент, который запомнили на место элемента, который переместили

		}
	}
}

void ShakerSort(int* MAS, int n) //функция шейкер сортировки
{
	int left = 0, right = n - 1; // Левая и правая границы массива
	int flag = 1;  // наличие перемещений
	while ((left < right) && flag > 0) // Выполнение цикла пока левая граница не будет равна правой и пока в массиве имеются перемещения
	{
		flag = 0;

		for (int i = left; i < right; i++)  // Двигаемся слева направо
		{
			if (MAS[i] > MAS[i+1]) // Если следующий элемент меньше текущего, то меняем их местами
			{
				int temp = MAS[i];
				MAS[i] = MAS[i + 1];
				MAS[i + 1] = temp;
				flag = 1;
			}
		}
		right--; // Сдвигаем правую границу влево на 1 элемент

		for (int i = right; i > left; i--)  // Двигаемся справа налево
		{
			if (MAS[i-1]>MAS[i]) // Если предыдущий элемент больше текущего, то меняем их местами
			{
				int temp = MAS[i];
				MAS[i] = MAS[i - 1];
				MAS[i - 1] = temp;
				flag = 1;
			}
		}
		left++; // Cдвигаем левую границу на 1 элемент вправо
	}
}