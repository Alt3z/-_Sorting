#include <iostream>

using namespace std;

void SortViborom(int* MAS, int n) //функция сортировки выбором по кнуту
{
    int rA, k;

    for (int i = n - 1; i > 0; i--)
    {
        rA = MAS[i]; //rA - текущий максимум
        k = i; //k - индекс
        for (int j = 0; j <= i; j++)
        {
            if (MAS[j] >= MAS[k]) //проверка: является ли текущий элемент больше или равен текущему максимуму
            {
                k = j; //новый индекс
                rA = MAS[k];
            }
        }
        MAS[k] = MAS[i]; //обмен
        MAS[i] = rA;
    }
}

void KvadratSort(int a[], int n)
{
    int n1 = sqrt(n); //вычисляем количество групп и количество элем в них
    int* b = new int[n1];//массив б
    int* c = new int[n];// массив с
    int min, imin;

    for (int z = 0; z < n; z++)
    {
        for (int i = 0; i < n1; i++)//внутренний цикл для прохода по 3 группам
        {
            min = a[i * n1]; //запоминаем первый элемент каждой группы
            imin = i * n1; //запоминаем индекс первого элемента каждой группы
            for (int j = imin + 1; (j < (i + 1) * n1) && (j < n); j++) // цикл, которые начинается со следующего элем. после первого и идет до первого элем след группы
            {
                if (a[j] <= min) //если нашли элемент меньший, чем мы запомнили раньше, то замоминаем его и его индекс
                {
                    min = a[j];
                    imin = j;
                }
            }
            b[i] = imin; //заносим индекс этого элемента в массив b
        }
        min = a[b[0]]; //запоминаем значение массива а с индексом значение b с индексом 0
        imin = 0; //обнуляем переменную 
        for (int i = 1; i < n1; i++)//цикл для прохода по группам
        {
            if (a[b[i]] < min) //если элемент из массива а с индексом,который мы храним в массиве b меньше чем число то, что мы уже запомнили
            { //то запоминаем новое значение
                min = a[b[i]];
                imin = i;
            }
        }
        c[z] = min;//заносим в массив с значение из массива а с индексом

        a[b[imin]] = 666; // изменяем занесенное значение на фиктивное
    }

    cout << endl << "Отсортированный массив: ";
    for (int i = 0; i < n; i++)
        cout << c[i] << " ";
}

int PIR(int A[], int i, int N) //для пирамидальной сортировки
{
    int imin, W;
    if ((2 * i + 2) < N)
    {
        if (A[2 * i + 1] > A[2 * i + 2])
            imin = 2 * i + 2;
        else
            imin = 2 * i + 1;
    }
    else imin = 2 * i + 1;

    if (imin >= N) return i;
    if (A[i] > A[imin])
    {
        W = A[i];
        A[i] = A[imin];
        A[imin] = W;
        if (imin < N / 2) i = imin;
    }
    return i;
}

void PirSort(int A[], int n) //Пирамидальная сортировка
{
    for (int i = n / 2 - 1; i >= 0; --i)
    {
        int ir = i;
        i = PIR(A, i, n);
        if (ir != i) ++i;
    }
    int W;
    for (int k = n - 1; k >= 0; --k)
    {
        W = A[0];
        A[0] = A[k];
        A[k] = W;
        int i1 = 0, ir = -1;
        while (i1 > ir)
        {
            ir = i1;
            i1 = PIR(A, i1, k);
        }
    }
    for (int i = 0; i < n / 2; i++)
    {
        W = A[i];
        A[i] = A[n - i - 1];
        A[n - i - 1] = W;
    }
}
